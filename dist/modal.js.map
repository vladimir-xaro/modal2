{"version":3,"file":"modal.js","sources":["../node_modules/@xaro/event-emitter/dist/event-emitter.es.js","../node_modules/@xaro/css-class-animations/node_modules/@xaro/micro-dom/dist/micro-dom.es.js","../node_modules/@xaro/css-class-animations/dist/css-class-animations.es.js","../node_modules/@xaro/deepmerge/index.js","../node_modules/@xaro/micro-dom/dist/micro-dom.es.js","../src/helpers.ts","../src/Modal.ts","../src/Helper.ts"],"sourcesContent":["export default class {\n    /**\n     * Event list\n     */\n    events={};\n    /**\n     * Create Emitter\n     */\n    constructor(e = {}) {\n        for (let s in e) e[s] && this.subscribe(s, e[s]);\n    }\n    /**\n     * Creates a key for the event and subscribes the passed callback to it.\n     */    subscribe(e, s) {\n        this.has(e) || (this.events[e] = []);\n        let t = [];\n        if (Array.isArray(s)) for (const r of s) t.push(...this.subscribe(e, r)); else this.events[e].push(s), \n        t.push((() => this.removeListener(e, s)));\n        return t;\n    }\n    /**\n     * Unsubscribes all callback functions from the event and removes the event\n     * key.\n     */    unsubscribe(...e) {\n        for (const s of e) this.events[s] && delete this.events[s];\n    }\n    /**\n     * Removes a specific event key callback function.\n     */    removeListener(e, s) {\n        // if (typeof this.events[key] === 'object') {\n        if (Array.isArray(this.events[e])) {\n            const t = this.events[e].indexOf(s);\n            t > -1 && this.events[e].splice(t, 1);\n        }\n    }\n    /**\n     * Calls the callback function only once, and then removes it.\n     */    once(e, s) {\n        const t = this.subscribe(e, (() => {\n            t[0](), Array.isArray(s) ? s.forEach((e => e())) : s();\n        }));\n    }\n    /**\n     * Checks for an event by key.\n     * (Doesn't check for callback functions)\n     */    has(e) {\n        return !!this.events[e];\n    }\n    /**\n     * Returns the number of callback functions for the event key or \"false\" if\n     * there is no key\n     */    listenerCount(e) {\n        return !!this.events.hasOwnProperty(e) && this.events[e].length;\n    }\n    /**\n     * Calls all callback functions on events using the event key.\n     */    emit(e, ...s) {\n        const t = this.events[e];\n        if (t) for (let e of t) e(...s);\n    }\n    /**\n     * Just like \"emit\" calls all callback functions. However, the callback must\n     * return a boolean value, which determines whether or not the next callback\n     * will execute.\n     * As a result, it returns the result of the last executed callback function.\n     */    validateEmit(e, ...s) {\n        const t = this.events[e];\n        if (!t) return !1;\n        for (const e of t) if (!e(...s)) return !1;\n        return !0;\n    }\n    /**\n     * Just like \"emit\" calls all callbacks, but unlike \"emit\" it passes the\n     * result of the previous callback to the next one as an argument.\n     * As aresult, it will return the result of the last callback.\n     */    seriesEmit(e, ...s) {\n        const t = this.events[e];\n        if (!t) return;\n        let r;\n        for (let e = 0; e < t.length; e++) r = 0 === e ? t[e](...s) : t[e](r);\n        return r;\n    }\n}\n//# sourceMappingURL=event-emitter.es.js.map\n","function t(t, ...e) {\n    const s = [];\n    for (const r of e) if (\"string\" == typeof r) {\n        const e = t.querySelectorAll(r);\n        s.push(...e);\n    } else r instanceof Element && s.push(r);\n    return s;\n}\n\nfunction e(t, ...s) {\n    for (const r of s) Array.isArray(r) ? e(t, ...r) : t.append(r);\n}\n\nfunction s(...t) {\n    const e = t, r = t.shift();\n    return r && setTimeout((() => {\n        r(), e.length && s(...e);\n    }), 0), this;\n}\n\nclass r extends Array {\n    constructor(...t) {\n        super(...t);\n    }\n    /**\n     * Returns a new instance containing the elements with the passed selectors and elements (or from the document if the current instance is empty)\n     */    get(...e) {\n        let s = new r;\n        if (this.length) for (const r of this) s.push(...t(r, ...e)); else s.push(...t(document, ...e));\n        return s;\n    }\n    /**\n     * Returns a new instance with new created elements according to the passed parameters\n     */    create(...t) {\n        let s = new r;\n        for (const r of t) if (\"string\" == typeof r) s.push(document.createElement(r)); else if (r instanceof Object) {\n            const t = document.createElement(r.tagName || \"div\");\n            r.content && (Array.isArray(r.content) ? e(t, ...r.content) : e(t, r.content)), \n            s.push(t);\n        }\n        return s;\n    }\n    /**\n     * Clears the contents of each element in the set and returns the instance itself\n     */    empty() {\n        return this.forEach((t => t.innerHTML = \"\")), this;\n    }\n    /**\n     * Sets the textContent property for each collection item and returns an instance\n     */    text(t) {\n        return this.forEach((e => e.textContent = t || \"\")), this;\n    }\n    /**\n     * Inserts a set of Node objects or DOMString objects after the last child of each array element\n     */    append(...t) {\n        return this.forEach((s => e(s, ...t))), this;\n    }\n    /**\n     * Adds a class or classes to all array elements\n     */    addClass(...t) {\n        return this.forEach((e => e.classList.add(...t))), this;\n    }\n    /**\n     * Removes a class or classes from all array elements\n     */    removeClass(...t) {\n        return this.forEach((e => e.classList.remove(...t))), this;\n    }\n    /**\n     * Adds or removes a class for each element of the array, depending on its presence\n     */    toggleClass(t) {\n        return this.forEach((e => e.classList.toggle(t))), this;\n    }\n    /**\n     * Determine if any of the agreed members are assigned to this class. Or, if you pass \"true\" as the second argument, then each element (default: reqtForAll = false)\n     */    hasClass(t, e = !1) {\n        if (e) {\n            // The presence of a class for each element of the set\n            let e = 0;\n            return this.forEach((s => {\n                s.classList.contains(t) && e++;\n            })), e === this.length;\n        }\n        // the presence of a class for at least one element of the set\n        for (const e of this) if (e.classList.contains(t)) return !0;\n        return !1;\n    }\n    /**\n     * Calls the \"addEventListener\" method for each set item\n     */    addEventListener(t, e, s) {\n        return this.forEach((r => r.addEventListener(t, e, s))), this;\n    }\n    /**\n     * Calls the \"removeEventListener\" method for each set item\n     */    removeEventListener(t, e, s) {\n        return this.forEach((r => r.removeEventListener(t, e, s))), this;\n    }\n    /**\n     * Calls dispatchEvent with an event of the specified type for each item in the set\n     */    fireEvent(t) {\n        return this.forEach((e => e.dispatchEvent(new Event(t)))), this;\n    }\n    /**\n     * Sets the style attribute property passed in the object by key\n     */    css(t) {\n        return this.forEach((e => Object.keys(t).forEach((s => e.style[s] = t[s])))), this;\n    }\n    /**\n     * Sets the attribute property passed in the object by key\n     */    attr(t) {\n        return this.forEach((e => Object.keys(t).forEach((s => e.setAttribute(s, t[s]))))), \n        this;\n    }\n    /**\n     * Recursively calls each passed function in a new setTimeout(() => {}, 0)\n     */    nextTick(...t) {\n        return s(...t), this;\n    }\n}\n\nfunction n(...e) {\n    return e instanceof r ? e : new r(...t(document, ...e));\n}\n\nexport default n;\n\nexport { r as MicroDOM, s as nextTick };\n//# sourceMappingURL=micro-dom.es.js.map\n","import t from \"@xaro/event-emitter\";\n\nimport i from \"@xaro/micro-dom\";\n\nconst e = {\n    animationstart: \"__mutationStartListener\",\n    animationcancel: \"__mutationCancelListener\",\n    animationend: \"__mutationEndListener\",\n    animationiteration: \"__mutationIterationListener\",\n    transitionstart: \"__mutationStartListener\",\n    transitioncancel: \"__mutationCancelListener\",\n    transitionend: \"__mutationEndListener\",\n    transitionrun: \"__mutationRunListener\"\n}, n = Object.keys(e);\n\nexport default class {\n    els;\n    emitter;\n    allow;\n    pending=!1;\n    constructor(s) {\n        this.emitter = new t(s.on), this.els = Array.isArray(s.el) ? i(...s.el) : i(s.el);\n        const r = s.allow, a = s.disallow;\n        r && r.length > 0 ? this.allow = (Array.isArray(r) ? r : [ r ]).filter((t => n.includes(t.toLowerCase()))) : a && a.length > 0 ? this.allow = (Array.isArray(a) ? a : [ a ]).filter((t => n.includes(t.toLowerCase()))) : this.allow = n, \n        // if (config.allow) {\n        //   this.allow = (Array.isArray(config.allow) ? config.allow : [ config.allow ]).filter(value => events.includes(value));\n        // } else if (config.disallow && config.disallow.length > 0) {\n        //   this.allow = (Array.isArray(config.disallow) ? config.disallow : [ config.disallow ]).filter(value => events.includes(value));\n        // } else {\n        //   this.allow = events;\n        // }\n        Object.keys(e).forEach((t => this[e[t]] = this[e[t]].bind(this))), this.els.forEach((t => this.allow.forEach((i => t.addEventListener(i, this[e[i]])))));\n    }\n    __mutationStartListener(t) {\n        this.pending = !0, this.emitter.emit(\"start\", t);\n    }\n    __mutationCancelListener(t) {\n        this.emitter.emit(\"cancel\", t), this.pending = !1;\n    }\n    __mutationEndListener(t) {\n        this.emitter.emit(\"end\", t), this.pending = !1;\n    }\n    __mutationIterationListener(t) {\n        this.emitter.emit(\"iteration\", t);\n    }\n    __mutationRunListener(t) {\n        this.pending = !0, this.emitter.emit(\"run\", t);\n    }\n    addEvent(t) {\n        n.includes(t) && (this.allow.push(t), this.els.forEach((i => i.addEventListener(t, this[e[t]]))));\n    }\n    removeEvent(t) {\n        n.includes(t) && this.allow.includes(t) && (this.allow.splice(this.allow.indexOf(t)), \n        this.els.forEach((i => i.removeEventListener(t, this[e[t]]))));\n    }\n    on(t, i) {\n        this.emitter.subscribe(t, i);\n    }\n}\n//# sourceMappingURL=css-class-animations.es.js.map\n","export function isObject(item) {\n  return (typeof item === 'object' && !Array.isArray(item) && item !== null);\n}\n\nexport default function deepmerge(target, source, options = {}) {\n  const mergeObject = options.mergeObject === undefined ? true : !!options.mergeObject;\n\n  if (isObject(target) && isObject(source)) {\n    for (const key of Object.keys(source)) {\n      if (mergeObject && isObject(source[key])) {\n        if (!target[key] || !isObject(target[key])) {\n          target[key] = source[key];\n        }\n\n        deepmerge(target[key], source[key]);\n      } else if (options.mergeArray && Array.isArray(source[key])) {\n        console.log(key);\n        if (Array.isArray(target[key])) {\n          target[key].push(...source[key]);\n        } else {\n          Object.assign(target, {\n            [key]: source[key]\n          })\n        }\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        })\n      }\n    }\n  }\n  return target;\n}","function getEls(target, ...els) {\n    const arr = [];\n    for (const el of els) if (\"string\" == typeof el) {\n        const nodes = target.querySelectorAll(el);\n        arr.push(...nodes);\n    } else el instanceof Element && arr.push(el);\n    return arr;\n}\n\nfunction recursiveAppend(el, ...content) {\n    for (const entity of content) Array.isArray(entity) ? recursiveAppend(el, ...entity) : el.append(entity);\n}\n\nfunction tickHelper(cbs, cb, num = 0) {\n    setTimeout((() => {\n        cb(), cbs.length && nextTick(...cbs);\n    }), num);\n}\n\nfunction nextTick(...cbs) {\n    const current = cbs.shift();\n    return \"function\" == typeof current ? tickHelper(cbs, current) : Array.isArray(current) && tickHelper(cbs, current[0], current[1]), \n    this;\n}\n\nclass MicroDOM extends Array {\n    constructor(...args) {\n        super(...args);\n    }\n    /**\n     * Returns a new instance containing the elements with the passed selectors and elements (or from the document if the current instance is empty)\n     */    get(...args) {\n        let newInstance = new MicroDOM;\n        if (this.length) for (const el of this) newInstance.push(...getEls(el, ...args)); else newInstance.push(...getEls(document, ...args));\n        return newInstance;\n    }\n    /**\n     * Returns a new instance with new created elements according to the passed parameters\n     */    create(...entities) {\n        let newInstance = new MicroDOM;\n        for (const entity of entities) if (\"string\" == typeof entity) newInstance.push(document.createElement(entity)); else if (entity instanceof Object) {\n            const el = document.createElement(entity.tagName || \"div\");\n            entity.content && (Array.isArray(entity.content) ? recursiveAppend(el, ...entity.content) : recursiveAppend(el, entity.content)), \n            newInstance.push(el);\n        }\n        return newInstance;\n    }\n    /**\n     * Clears the contents of each element in the set and returns the instance itself\n     */    empty() {\n        return this.forEach((el => el.innerHTML = \"\")), this;\n    }\n    /**\n     * Sets the textContent property for each collection item and returns an instance\n     */    text(text) {\n        return this.forEach((el => el.textContent = text || \"\")), this;\n    }\n    /**\n     * Inserts a set of Node objects or DOMString objects after the last child of each array element\n     */    append(...append) {\n        return this.forEach((el => recursiveAppend(el, ...append))), this;\n    }\n    /**\n     * Adds a class or classes to all array elements\n     */    addClass(...classes) {\n        return this.forEach((el => el.classList.add(...classes))), this;\n    }\n    /**\n     * Removes a class or classes from all array elements\n     */    removeClass(...classes) {\n        return this.forEach((el => el.classList.remove(...classes))), this;\n    }\n    /**\n     * Adds or removes a class for each element of the array, depending on its presence\n     */    toggleClass(classname) {\n        return this.forEach((el => el.classList.toggle(classname))), this;\n    }\n    /**\n     * Determine if any of the agreed members are assigned to this class. Or, if you pass \"true\" as the second argument, then each element (default: reqtForAll = false)\n     */    hasClass(classname, reqtForAll = !1) {\n        let newInstance = new MicroDOM;\n        if (reqtForAll) // The presence of a class for each element of the set\n        return this.forEach((el => {\n            el.classList.contains(classname) && newInstance.push(el);\n        })), newInstance;\n        // the presence of a class for at least one element of the set\n        for (const el of this) el.classList.contains(classname) && newInstance.push(el);\n        return newInstance;\n    }\n    /**\n     * Calls the \"addEventListener\" method for each set item\n     */    addEventListener(type, listener, options) {\n        return this.forEach((el => el.addEventListener(type, listener, options))), this;\n    }\n    /**\n     * Calls the \"removeEventListener\" method for each set item\n     */    removeEventListener(type, listener, options) {\n        return this.forEach((el => el.removeEventListener(type, listener, options))), this;\n    }\n    /**\n     * Calls dispatchEvent with an event of the specified type for each item in the set\n     */    fireEvent(type) {\n        return this.forEach((el => el.dispatchEvent(new Event(type)))), this;\n    }\n    /**\n     * Sets the style attribute property passed in the object by key\n     */    css(obj) {\n        return this.forEach((el => Object.keys(obj).forEach((key => el.style[key] = obj[key])))), \n        this;\n    }\n    /**\n     * Sets the attribute property passed in the object by key\n     */    attr(obj) {\n        return this.forEach((el => Object.keys(obj).forEach((key => el.setAttribute(key, obj[key]))))), \n        this;\n    }\n    /**\n     * Recursively calls each passed function in a new setTimeout(() => {}, 0)\n     */    nextTick(...cbs) {\n        return nextTick(...cbs), this;\n    }\n}\n\nfunction _(...args) {\n    return args instanceof MicroDOM ? args : new MicroDOM(...getEls(document, ...args));\n}\n\nexport default _;\n\nexport { MicroDOM, nextTick };\n//# sourceMappingURL=micro-dom.es.js.map\n","import { nextTick } from \"@xaro/micro-dom\";\nimport CSSClassAnimations from \"@xaro/css-class-animations\";\n\nexport const animate = (\n  animInst:   CSSClassAnimations,\n  from:       string,\n  active:     string,\n  to:         string,\n  afterEnd?:  Function,\n): void => {\n  animInst.els.addClass(from);\n\n  nextTick(\n    [\n      () => animInst.els.addClass(active),\n      10\n    ], [\n      () => animInst.els.removeClass(from),\n      10\n    ], [\n      () => {\n        animInst.emitter.once('end', () => {\n          animInst.els.removeClass(to, active)\n          afterEnd && afterEnd();\n        });\n        animInst.els.addClass(to);\n      },\n      10\n    ]\n  );\n}\n\nexport const undefinedBool = (val: any, def: boolean) => typeof val === 'undefined' ? def : val;","import CSSClassAnimations, {\n  DOMEventsKeys as CSSAnimationsEventsKey\n} from \"@xaro/css-class-animations\";\nimport EventEmitter from \"@xaro/event-emitter\";\nimport deepmerge, { isObject } from \"@xaro/deepmerge\";\nimport HelperCtor from \"./Helper\";\nimport Helper from \"./types/Helper\";\nimport { animate, undefinedBool } from \"./helpers\";\nimport I_Modal, {\n  ModalCfg,\n  ModalChangeCfg,\n  ModalCtorCfg,\n  ModalHideCfg,\n  ModalShowCfg\n} from \"./types/Modal\";\n\nconst defaultClasses = {\n  show:     'modal--show',\n  wrapper:  'modal__wrapper',\n  content:  'modal__content',\n  transition: {\n    hide: {\n      from:   'modal-t-hide-from',\n      active: 'modal-t-hide-active',\n      to:     'modal-t-hide-to',\n    },\n    show: {\n      from:   'modal-t-show-from',\n      active: 'modal-t-show-active',\n      to:     'modal-t-show-to',\n    },\n  }\n};\n\nconst defaultAttrs = {\n  modalId:  'data-modal-id',\n  close:    'data-modal-close',\n};\n\nexport default class Modal implements I_Modal {\n  static instances: Modal[] = [];\n  static queue:     Modal[] = [];\n  static isFirst:   boolean = true;\n\n  static addsEscListener() {\n    document.addEventListener('keyup', (event: KeyboardEvent) => {\n      let length;\n      if (event.code === 'Escape' && (length = Modal.queue.length)) {\n        Modal.queue[length - 1].hide()\n      }\n    });\n  }\n\n  static showById(id: string) {\n    if (id === undefined) {\n      return;\n    }\n    for (const modal of Modal.instances) {\n      if (id === modal.config.id) {\n        modal.show();\n        return;\n      }\n    }\n  }\n\n  emitter:      EventEmitter;\n  config:       ModalCfg;\n  helper:       Helper;\n  animContent?: CSSClassAnimations;\n  bluredEl?:    Element;\n\n  constructor(config: ModalCtorCfg) {\n    // First init\n    if (Modal.isFirst) {\n      Modal.addsEscListener();\n\n      Modal.isFirst = false;\n    }\n\n    const el = config.el;\n\n    // Checks if an instance with this element exists\n    if (el.__modalIsInit) {\n      for (const modal of Modal.instances) {\n        if (el === modal.config.el) {\n          return modal;\n        }\n      }\n    } else {\n      el.__modalIsInit = true;\n    }\n\n    this.emitter = new EventEmitter(config.on);\n    \n    const _classes = isObject(config.classes) ?\n      deepmerge(defaultAttrs, config.classes) :\n      defaultClasses;\n    const _attrs = isObject(config.attrs) ?\n      deepmerge(defaultAttrs, config.attrs) :\n      defaultAttrs;\n    \n    this.config = {\n      el:             el,\n      wrapper:        el.querySelector(`.${_classes.wrapper}`),\n      content:        el.querySelector(`.${_classes.content}`),\n      isVisible:      false,\n      pending:        false,\n      mutation:       config.mutation || false,\n      attrClose:      undefinedBool(config.attrClose, true),\n      wrapperClick:   undefinedBool(config.wrapperClick, true),\n      allowEsc:       undefinedBool(config.allowEsc, true),\n      classes:        _classes,\n      attrs:          _attrs\n    };\n    let _id;\n    this.config.id = (_id = el.getAttribute(_attrs.modalId)) ? _id : undefined;\n\n    Modal.instances.push(this);\n\n    this.helper = new HelperCtor;\n    if (this.config.mutation) {\n      this.animContent = new CSSClassAnimations({\n        el:     this.config.content,\n        allow:  this.config.mutation + 'end' as CSSAnimationsEventsKey,\n      })\n    }\n\n    if (this.config.attrClose) {\n      this.config.el.querySelectorAll(`[${this.config.attrs.close}]`).forEach(el => {\n        el.addEventListener('click', () => this.hide());\n      });\n    }\n\n    if (this.config.wrapperClick) {\n      this.config.wrapper.addEventListener('click', (event: Event) => {\n        if (event.target === this.config.wrapper) {\n          this.hide();\n        }\n      });\n    }\n\n    this.emitter.emit('init', this, this.config.isVisible);\n\n    if (config.showOnInit) {\n      this.show();\n    }\n  }\n\n  changeState(hide: boolean, config?: ModalChangeCfg) {\n    if (this.config.pending) {\n      this.helper.cb = () => this.changeState(hide);\n      return;\n    }\n\n    this.config.isVisible = !hide;\n\n    if (this.config.mutation) {\n      this.config.pending = true;\n\n      if (hide) {\n        this.emitter.emit('beforeHide', this, this.config.mutation);\n\n        let qI = Modal.queue.indexOf(this);\n        Modal.queue.splice(qI, 1);\n\n        animate(\n          this.animContent,\n          this.config.classes.transition.hide.from,\n          this.config.classes.transition.hide.active,\n          this.config.classes.transition.hide.to,\n          () => {\n            this.config.el.classList.remove(this.config.classes.show);\n            this.config.pending = false;\n            const cb = this.helper.cb;\n            delete this.helper.cb;\n            this.emitter.emit('afterHide', this, this.config.mutation);\n            cb && cb(this);\n          }\n        );\n      } else {\n        this.emitter.emit('beforeShow', this, this.config.mutation);\n\n        Modal.queue.push(this);\n\n        this.config.el.classList.add(this.config.classes.show);\n        animate(\n          this.animContent,\n          this.config.classes.transition.show.from,\n          this.config.classes.transition.show.active,\n          this.config.classes.transition.show.to,\n          () => {\n            this.config.pending = false;\n            const cb = this.helper.cb;\n            delete this.helper.cb;\n            this.emitter.emit('afterShow', this, this.config.mutation);\n            cb && cb(this);\n          }\n        );\n      }\n    } else {\n      if (hide) {\n        this.emitter.emit('beforeHide', this, this.config.mutation);\n\n        let qI = Modal.queue.indexOf(this);\n        Modal.queue.splice(qI, 1);\n\n        this.config.el.classList.remove(this.config.classes.show);\n        this.emitter.emit('afterHide', this, this.config.mutation);\n      } else {\n        this.emitter.emit('beforeShow', this, this.config.mutation);\n\n        Modal.queue.push(this);\n\n        this.config.el.classList.add(this.config.classes.show);\n        this.emitter.emit('afterShow', this, this.config.mutation);\n      }\n    }\n\n    if (hide) {\n      if (! Modal.queue.length) {\n        document.body.classList.remove('modal-shown');\n      }\n    } else {\n      document.body.classList.add('modal-shown');\n    }\n  }\n\n  show(config?: ModalShowCfg): void {\n    if (this.config.isVisible) {\n      return;\n    }\n\n    this.bluredEl = document.activeElement;\n\n    this.changeState(false, config);\n  }\n  hide(config?: ModalHideCfg) {\n    if (! this.config.isVisible) {\n      return;\n    }\n\n    this.changeState(true, config);\n\n    if (config) {\n      if (config.focusBluredEl) {\n        (this.bluredEl as unknown as HTMLOrSVGElement).focus();\n        this.bluredEl = undefined;\n      }\n    }\n  }\n\n  toggle() {\n    if (this.config.isVisible) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n}","import I_Helper from \"./types/Helper\";\n\nconst Helper = class implements I_Helper {\n  cb?: Function;\n}\n\nexport default Helper;"],"names":["[object Object]","on","key","this","subscribe","cb","has","events","removes","Array","isArray","_cb","push","removeListener","keys","idx","indexOf","splice","remove","forEach","hasOwnProperty","length","args","event","params","i","getEls","target","els","arr","el","nodes","querySelectorAll","Element","recursiveAppend","content","entity","append","nextTick","cbs","current","shift","setTimeout","eventsListeners","animationstart","animationcancel","animationend","animationiteration","transitionstart","transitioncancel","transitionend","transitionrun","Object","isObject","item","deepmerge","source","options","mergeObject","undefined","mergeArray","console","log","assign","tickHelper","num","animate","animInst","from","active","to","afterEnd","addClass","removeClass","emitter","once","undefinedBool","val","def","defaultClasses","show","wrapper","transition","hide","defaultAttrs","modalId","close","Modal","document","addEventListener","code","queue","id","modal","instances","config","isFirst","addsEscListener","__modalIsInit","EventEmitter","_classes","classes","_attrs","attrs","_id","querySelector","isVisible","pending","mutation","attrClose","wrapperClick","allowEsc","getAttribute","helper","animContent","CSSClassAnimations","allow","emit","showOnInit","changeState","qI","classList","add","body","bluredEl","activeElement","focusBluredEl","focus"],"mappings":"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"}